<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.16.0/dist/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets@11.8.0/styles/default.min.css">
</head>
<link rel="stylesheet" href="./UML.md">
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.16.0/dist/browser/index.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.16.0/dist/index.js"></script><script>(()=>{setTimeout(()=>{const{markmap:H,mm:ae}=window,W=new H.Toolbar;W.attach(ae);const we=W.render();we.setAttribute("style","position:absolute;bottom:20px;right:20px"),document.body.append(we)})})()</script><script>((o,T,c,r)=>{const g=o();window.mm=g.Markmap.create("svg#mindmap",(T||g.deriveOptions)(r),c)})(()=>window.markmap,null,{"content":"UT 4: DIAGRAMAS DE ESTADO","children":[{"content":"introducción","children":[{"content":"1. ¿Por qué modelamos?","children":[{"content":"1. <strong>Clarificación de Requisitos:</strong>","children":[{"content":"La modelación ayuda a comprender y clarificar los requisitos del sistema. Al representar visualmente las entidades, relaciones y comportamientos esperados, los stakeholders pueden revisar y validar sus expectativas antes de que se realice la implementación.","children":[],"payload":{"lines":"14,16"}}],"payload":{"lines":"13,14"}},{"content":"2. <strong>Visualización del Diseño:</strong>","children":[{"content":"Los modelos proporcionan una representación visual de la arquitectura y el diseño del sistema. Esto facilita la comunicación entre los miembros del equipo de desarrollo, permitiéndoles entender rápidamente la estructura y las interacciones planeadas.","children":[],"payload":{"lines":"17,19"}}],"payload":{"lines":"16,17"}},{"content":"3. <strong>Identificación de Problemas de Diseño:</strong>","children":[{"content":"La modelación permite identificar posibles problemas de diseño antes de la implementación. Al visualizar la estructura y las relaciones, es más fácil detectar conflictos, redundancias o áreas de mejora en el diseño.","children":[],"payload":{"lines":"20,22"}}],"payload":{"lines":"19,20"}},{"content":"4. <strong>Facilita la Toma de Decisiones:</strong>","children":[{"content":"Los modelos proporcionan una base para la toma de decisiones informadas. Los diseñadores y stakeholders pueden evaluar diferentes opciones de diseño, comparar alternativas y tomar decisiones basadas en una comprensión clara de las implicaciones.","children":[],"payload":{"lines":"23,25"}}],"payload":{"lines":"22,23"}},{"content":"5. <strong>Alineación con Objetivos del Negocio:</strong>","children":[{"content":"La modelación ayuda a garantizar que el diseño del software esté alineado con los objetivos del negocio. Permite visualizar cómo las funcionalidades planeadas satisfacen los requisitos empresariales y facilita la comunicación entre los equipos técnicos y no técnicos.","children":[],"payload":{"lines":"26,28"}}],"payload":{"lines":"25,26"}},{"content":"6. <strong>Ahorro de Recursos:</strong>","children":[{"content":"Identificar y corregir problemas de diseño antes de la implementación puede ahorrar tiempo y recursos. La modelación ayuda a evitar costosos retrabajos y cambios de último minuto al proporcionar una oportunidad para revisar y validar el diseño antes de que se invierta en la implementación.","children":[],"payload":{"lines":"29,31"}}],"payload":{"lines":"28,29"}},{"content":"7. <strong>Documentación Efectiva:</strong>","children":[{"content":"Los modelos actúan como una forma de documentación efectiva. Proporcionan una representación visual que es fácil de entender y mantener. Los desarrolladores pueden referirse a los modelos durante la implementación para garantizar que sigan las pautas y la visión del diseño.","children":[],"payload":{"lines":"32,34"}}],"payload":{"lines":"31,32"}},{"content":"8. <strong>Mejora la Colaboración:</strong>","children":[{"content":"La modelación fomenta la colaboración entre los miembros del equipo y los stakeholders. Proporciona un lenguaje común para discutir y compartir ideas, facilitando la comprensión mutua y reduciendo malentendidos.","children":[],"payload":{"lines":"35,37"}}],"payload":{"lines":"34,35"}}],"payload":{"lines":"5,6"}},{"content":"2. Los diagramas de clases y el desarrollo de software","children":[{"content":"1. <strong>Visualización de la Estructura del Sistema:</strong>","children":[{"content":"Los diagramas de clases proporcionan una representación visual de las clases en el sistema, sus atributos y sus relaciones. Esto facilita la comprensión de la estructura general del sistema y cómo se organizan las entidades clave.","children":[],"payload":{"lines":"46,48"}}],"payload":{"lines":"45,46"}},{"content":"2. <strong>Identificación de Clases y Relaciones:</strong>","children":[{"content":"Permiten identificar las clases que formarán parte del sistema y las relaciones entre ellas. Esto ayuda a los diseñadores a tomar decisiones sobre cómo organizar las funcionalidades del sistema en unidades cohesivas y acopladas de manera adecuada.","children":[],"payload":{"lines":"49,51"}}],"payload":{"lines":"48,49"}},{"content":"3. <strong>Diseño de Interfaces y Colaboraciones:</strong>","children":[{"content":"Los diagramas de clases permiten definir las interfaces de las clases y cómo interactúan entre sí. Esto es crucial para establecer la comunicación y las colaboraciones entre diferentes partes del sistema, ayudando a prever y planificar la implementación de funciones específicas.","children":[],"payload":{"lines":"52,54"}}],"payload":{"lines":"51,52"}},{"content":"4. <strong>Modelado de Atributos y Métodos:</strong>","children":[{"content":"Los atributos y métodos de las clases se modelan en los diagramas de clases, lo que proporciona una visión detallada de la implementación prevista. Esto es esencial para garantizar que las clases tengan las responsabilidades adecuadas y que los datos y comportamientos estén bien encapsulados.","children":[],"payload":{"lines":"55,57"}}],"payload":{"lines":"54,55"}},{"content":"5. <strong>Facilita la Comunicación del Diseño:</strong>","children":[{"content":"Los diagramas de clases sirven como una herramienta de comunicación efectiva entre los miembros del equipo de desarrollo. Los diseñadores pueden expresar sus ideas y decisiones de diseño de manera visual y comprensible, lo que facilita la colaboración y la discusión en el equipo.","children":[],"payload":{"lines":"58,60"}}],"payload":{"lines":"57,58"}},{"content":"6. <strong>Identificación de Patrones de Diseño:</strong>","children":[{"content":"Al utilizar diagramas de clases, los diseñadores pueden identificar patrones de diseño que podrían ser aplicados para resolver problemas comunes de diseño de manera efectiva y eficiente.","children":[],"payload":{"lines":"61,63"}}],"payload":{"lines":"60,61"}},{"content":"7. <strong>Base para la Implementación:</strong>","children":[{"content":"Los diagramas de clases sirven como una guía sólida para la implementación del código. Los desarrolladores pueden referirse a estos diagramas para entender la estructura del sistema y traducir el diseño en código de manera coherente.","children":[],"payload":{"lines":"64,66"}}],"payload":{"lines":"63,64"}}],"payload":{"lines":"39,40"}}],"payload":{"lines":"3,4"}},{"content":"POO","children":[{"content":"3. Diseño y Programación Orientada a Objetos","children":[{"content":"<strong>Programación Estructurada:</strong>","children":[{"content":"<strong>Enfoque:</strong> Se centra en procedimientos y funciones.","children":[],"payload":{"lines":"81,82"}},{"content":"<strong>Unidades de Programación:</strong> Se organiza en funciones o procedimientos que realizan tareas específicas.","children":[],"payload":{"lines":"82,83"}},{"content":"<strong>Datos y Funciones:</strong> Los datos y funciones están separados; las funciones manipulan datos.","children":[],"payload":{"lines":"83,84"}},{"content":"<strong>Reutilización de Código:</strong> A través de funciones y procedimientos.","children":[],"payload":{"lines":"84,85"}},{"content":"<strong>Modularidad:</strong> Se logra mediante la creación de bloques de código independientes.","children":[],"payload":{"lines":"85,86"}},{"content":"<strong>Herencia y Polimorfismo:</strong> No son conceptos fundamentales en la programación estructurada.","children":[],"payload":{"lines":"86,88"}}],"payload":{"lines":"80,81"}},{"content":"<strong>Programación Orientada a Objetos (POO):</strong>","children":[{"content":"<strong>Enfoque:</strong> Se centra en objetos que encapsulan datos y comportamientos.","children":[],"payload":{"lines":"89,90"}},{"content":"<strong>Unidades de Programación:</strong> Se organiza en clases y objetos.","children":[],"payload":{"lines":"90,91"}},{"content":"<strong>Datos y Funciones:</strong> Los datos y funciones se encapsulan en objetos; la manipulación se realiza mediante métodos.","children":[],"payload":{"lines":"91,92"}},{"content":"<strong>Reutilización de Código:</strong> A través de la herencia y la composición, se fomenta una reutilización más flexible y extensible.","children":[],"payload":{"lines":"92,93"}},{"content":"<strong>Modularidad:</strong> Se logra mediante la encapsulación y la creación de clases.","children":[],"payload":{"lines":"93,94"}},{"content":"<strong>Herencia y Polimorfismo:</strong> Conceptos clave que permiten la extensión y adaptación de clases existentes.","children":[],"payload":{"lines":"94,96"}}],"payload":{"lines":"88,89"}},{"content":"<strong>Razones para la Popularidad de la POO:</strong>","children":[{"content":"<strong>Modelado del Mundo Real:</strong> La POO permite modelar sistemas de software de manera más cercana al mundo real, facilitando la comprensión y el diseño.","children":[],"payload":{"lines":"97,98"}},{"content":"<strong>Reutilización y Mantenimiento:</strong> La reutilización de código a través de la herencia y la composición facilita el mantenimiento y la extensión de sistemas.","children":[],"payload":{"lines":"98,99"}},{"content":"<strong>Modularidad y Escalabilidad:</strong> La POO proporciona una estructura modular, facilitando el desarrollo de sistemas grandes y complejos.","children":[],"payload":{"lines":"99,100"}},{"content":"<strong>Abstracción y Encapsulamiento:</strong> La capacidad de abstracción y encapsulamiento permite ocultar detalles internos y exponer solo la interfaz necesaria.","children":[],"payload":{"lines":"100,101"}},{"content":"<strong>Mejora de la Colaboración:</strong> La POO facilita la colaboración en equipos grandes al proporcionar un marco conceptual compartido.","children":[],"payload":{"lines":"101,102"}},{"content":"<strong>Adaptabilidad:</strong> La herencia y el polimorfismo permiten adaptar y extender clases existentes sin modificar su código fuente.","children":[],"payload":{"lines":"102,104"}}],"payload":{"lines":"96,97"}}],"payload":{"lines":"70,71"}},{"content":"4. Elementos de la Programación Orientada a Objetso","children":[{"content":"<strong>Clases y Objetos:</strong>","children":[{"content":"<strong>Clase:</strong> Una clase en programación orientada a objetos (POO) es un modelo o plantilla para crear objetos. Define la estructura y el comportamiento común a todos los objetos que se crearán a partir de ella. Las clases contienen atributos y métodos que describen las características y acciones de los objetos.","children":[],"payload":{"lines":"110,111"}},{"content":"<strong>Objeto:</strong> Un objeto es una instancia particular de una clase. Representa un componente individual del sistema que puede tener sus propios datos (atributos) y realizar acciones (métodos). Los objetos se crean a partir de las clases y encapsulan el estado y el comportamiento específicos.","children":[],"payload":{"lines":"111,113"}}],"payload":{"lines":"109,110"}},{"content":"<strong>Métodos y Mensajes:</strong>","children":[{"content":"<strong>Método:</strong> Un método es una función o procedimiento asociado a una clase u objeto en POO. Representa el comportamiento o las acciones que los objetos de esa clase pueden realizar. Los métodos operan sobre los datos (atributos) de la clase o del objeto.","children":[],"payload":{"lines":"114,115"}},{"content":"<strong>Mensaje:</strong> En POO, la comunicación entre objetos se realiza mediante mensajes. Un mensaje es una solicitud para que un objeto ejecute uno de sus métodos. Cuando un objeto recibe un mensaje, realiza la acción correspondiente invocando el método asociado.","children":[],"payload":{"lines":"115,117"}}],"payload":{"lines":"113,114"}},{"content":"<strong>Atributos y Estado:</strong>","children":[{"content":"<strong>Atributo:</strong> Un atributo es una propiedad o característica de una clase u objeto que define su estado. También se conocen como campos, propiedades o variables de instancia. Los atributos representan datos que describen las características de un objeto.","children":[],"payload":{"lines":"118,119"}},{"content":"<strong>Estado:</strong> El estado de un objeto es la combinación actual de sus atributos en un momento dado. Cambiar el valor de los atributos de un objeto altera su estado. El estado de un objeto refleja la información relevante sobre su condición en un instante específico. El estado de un objeto puede variar a lo largo del tiempo.","children":[],"payload":{"lines":"119,121"}}],"payload":{"lines":"117,118"}},{"content":"<strong>Constructores</strong>","children":[{"content":"<pre data-lines=\"140,161\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Persona</span> {\n    <span class=\"hljs-comment\">// Atributos</span>\n    String nombre;\n    <span class=\"hljs-type\">int</span> edad;\n\n    <span class=\"hljs-comment\">// Constructor sin parámetros</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Persona</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-comment\">// Inicialización por defecto</span>\n        nombre = <span class=\"hljs-string\">\"Sin nombre\"</span>;\n        edad = <span class=\"hljs-number\">0</span>;\n    }\n\n    <span class=\"hljs-comment\">// Constructor con parámetros</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Persona</span><span class=\"hljs-params\">(String nombre, <span class=\"hljs-type\">int</span> edad)</span> {\n        <span class=\"hljs-comment\">// Inicialización con valores proporcionados</span>\n        <span class=\"hljs-built_in\">this</span>.nombre = nombre;\n        <span class=\"hljs-built_in\">this</span>.edad = edad;\n    }\n}\n</code></pre>","children":[],"payload":{"lines":"140,161"}}],"payload":{"lines":"121,122"}}],"payload":{"lines":"107,108"}}],"payload":{"lines":"68,69"}},{"content":"5. Características de los objetos","children":[{"content":"<strong>Abstracción:</strong>","children":[{"content":"La abstracción es esencial para modelar entidades del mundo real de manera efectiva, enfocándose en las características clave y despreciando los detalles no esenciales. Tomemos el ejemplo de una clase \"Coche\". En un contexto de modelado para carreras, podríamos abstraer las características relevantes como la velocidad máxima, el tipo de neumáticos y la aerodinámica. Por otro lado, en un contexto de gestión de multas de tráfico, las características relevantes podrían incluir la matrícula, la velocidad actual y la información del propietario. La abstracción permite adaptar la representación del objeto según el contexto específico.","children":[],"payload":{"lines":"176,178"}}],"payload":{"lines":"174,175"}},{"content":"<strong>Visibilidad y Encapsulamiento:</strong>","children":[{"content":"La visibilidad y el encapsulamiento controlan el acceso a los elementos de una clase y ayudan a mantener la integridad del objeto. Consideremos dos clases, \"Motor\" y \"Puerta\", dentro de la clase \"Coche\". Podemos definir ciertos atributos y métodos como privados (por ejemplo, la temperatura interna del motor) y otros como públicos (por ejemplo, métodos para abrir y cerrar las puertas). El encapsulamiento asegura que solo las partes necesarias del objeto sean accesibles desde fuera, manteniendo la coherencia interna y facilitando cambios internos sin afectar el resto del sistema.","children":[],"payload":{"lines":"180,182"}}],"payload":{"lines":"178,179"}},{"content":"<strong>Herencia:</strong>","children":[{"content":"La herencia facilita la reutilización del código y establece relaciones entre clases. Siguiendo con el ejemplo de \"Coche\", podríamos tener una clase base \"Coche\" de la cual derivan dos subclases: \"CocheDeCarreras\" y \"CocheDeMultas\". La herencia permite a ambas subclases heredar atributos y comportamientos comunes de la clase base, como el modelo y la velocidad máxima, mientras que cada una puede tener características específicas adicionales.","children":[],"payload":{"lines":"184,186"}}],"payload":{"lines":"182,183"}},{"content":"<strong>Polimorfismo:</strong>","children":[{"content":"El polimorfismo permite tratar objetos de manera uniforme a través de interfaces comunes. Siguiendo con las subclases \"CocheDeCarreras\" y \"CocheDeMultas\", podríamos tener un método común llamado \"Acelerar\". Aunque la implementación exacta de \"Acelerar\" difiere entre las subclases, el polimorfismo permite invocar el mismo método en ambas, lo que facilita el diseño y la gestión del código.","children":[],"payload":{"lines":"188,190"}}],"payload":{"lines":"186,187"}},{"content":"<strong>Sobrecarga:</strong>","children":[{"content":"La sobrecarga permite definir múltiples versiones de un método con el mismo nombre pero con diferentes parámetros. Consideremos una clase \"Coche\" que tenga un método \"Acelerar\" sobrecargado. Dependiendo de la versión del método (por ejemplo, aceleración normal o aceleración rápida), el comportamiento puede variar.","children":[],"payload":{"lines":"192,194"}}],"payload":{"lines":"190,191"}},{"content":"<strong>Sobrescritura:</strong>","children":[{"content":"La sobrescritura se aplica cuando una subclase proporciona su propia implementación para un método heredado de la superclase. En el ejemplo de las subclases \"CocheDeCarreras\" y \"CocheDeMultas\", ambas podrían sobrescribir el método \"Acelerar\" para adaptarse a sus necesidades específicas, demostrando la flexibilidad y adaptabilidad que proporciona la POO.","children":[],"payload":{"lines":"196,198"}}],"payload":{"lines":"194,195"}}],"payload":{"lines":"168,169"}},{"content":"UML","children":[{"content":"6. Diagramas de clases","children":[{"content":"1. <strong>Nombre de la Clase:</strong>","children":[{"content":"En la parte superior de la caja que representa la clase, se coloca el nombre de la clase. Este es un elemento esencial y sirve para identificar la clase. Se deben nombrar con la notación CamelCase en mayúsculas","children":[],"payload":{"lines":"207,209"}}],"payload":{"lines":"206,207"}},{"content":"2. <strong>Atributos:</strong>","children":[{"content":"Directamente debajo del nombre de la clase, se enumeran los atributos de la clase. Cada atributo se presenta en la forma \"visibilidad nombre: tipo = valor inicial\". La visibilidad puede ser pública (+), privada (-), o protegida (#). El tipo representa el tipo de dato del atributo, y el valor inicial indica un valor predeterminado opcional.","children":[],"payload":{"lines":"210,212"}}],"payload":{"lines":"209,210"}},{"content":"3. <strong>Métodos:</strong>","children":[{"content":"Los métodos se representan debajo de los atributos en la forma \"visibilidad nombre(parametros): tipoRetorno\". Al igual que con los atributos, la visibilidad indica la accesibilidad del método.","children":[],"payload":{"lines":"213,215"}}],"payload":{"lines":"212,213"}},{"content":"4. <strong>Compartimentos:</strong>","children":[{"content":"La clase puede dividirse en compartimentos que contienen atributos y métodos. Los compartimentos pueden ser separados para atributos y métodos públicos, privados o protegidos, proporcionando una organización clara.","children":[],"payload":{"lines":"216,218"}}],"payload":{"lines":"215,216"}},{"content":"5. <strong>Visibilidad:</strong>","children":[{"content":"La visibilidad se representa mediante símbolos antes del nombre del atributo o método. Los símbolos más comunes son \"+\" para público, \"-\" para privado y \"#\" para protegido.","children":[],"payload":{"lines":"219,221"}}],"payload":{"lines":"218,219"}},{"content":"6. <strong>Tipo:</strong>","children":[{"content":"El tipo de dato de los atributos y el tipo de retorno de los métodos se especifican después de los dos puntos (:). Puede ser cualquier tipo de dato válido en el lenguaje de programación que se esté modelando.","children":[],"payload":{"lines":"222,224"}}],"payload":{"lines":"221,222"}},{"content":"7. <strong>Multiplicidad:</strong>","children":[{"content":"La multiplicidad indica cuántas instancias de una clase están asociadas con otra. Se representa como un rango entre corchetes. Por ejemplo, \"1..*\" indica que puede haber uno o más elementos asociados.","children":[],"payload":{"lines":"225,227"}}],"payload":{"lines":"224,225"}},{"content":"8. <strong>Valor Inicial:</strong>","children":[{"content":"Se utiliza para proporcionar un valor predeterminado para un atributo. Se coloca después del signo igual (=). No todos los atributos necesitan tener un valor inicial.","children":[],"payload":{"lines":"228,230"}}],"payload":{"lines":"227,228"}}],"payload":{"lines":"200,201"}},{"content":"Relaciones entre clases","children":[{"content":"1. <strong>Asociación:</strong>","children":[{"content":"<strong>Definición:</strong> Representa una relación entre dos clases donde un objeto de una clase está relacionado con un objeto de otra clase. Puede ser unidireccional o bidireccional.","children":[{"content":"<strong>Unidireccional:</strong> Una clase está asociada con otra, pero la asociación es unidireccional. Se representa con una línea sólida que va desde la clase de origen a la clase de destino.","children":[],"payload":{"lines":"238,239"}},{"content":"<strong>Bidireccional:</strong> Ambas clases están asociadas entre sí. Se representan con una línea sólida que conecta ambas clases.","children":[],"payload":{"lines":"239,240"}}],"payload":{"lines":"237,240"}},{"content":"<strong>Ejemplo UML:</strong>","children":[{"content":"Unidireccional: <code>A --&gt; B</code>","children":[],"payload":{"lines":"241,242"}},{"content":"Bidireccional: <code>A &lt;--&gt; B</code>","children":[],"payload":{"lines":"242,244"}}],"payload":{"lines":"240,244"}}],"payload":{"lines":"236,237"}},{"content":"2. <strong>Agregación:</strong>","children":[{"content":"<strong>Definición:</strong> Representa una relación de \"todo-parte\", donde una clase (todo) contiene a otra clase (parte). La parte puede existir de forma independiente de la clase contenedora.","children":[],"payload":{"lines":"245,246"}},{"content":"Se representa con un rombo hueco en la clase contenedora.","children":[],"payload":{"lines":"246,247"}},{"content":"<strong>Ejemplo UML:</strong>","children":[{"content":"Rombo hueco en la clase contenedora: <code>A &lt;&gt;-- B</code>","children":[],"payload":{"lines":"248,250"}}],"payload":{"lines":"247,250"}}],"payload":{"lines":"244,245"}},{"content":"3. <strong>Composición:</strong>","children":[{"content":"<pre data-lines=\"251,252\"><code>- **Definición:** Similar a la agregación, pero en este caso la parte no puede existir de forma independiente de la clase contenedora. La existencia de la parte está fuertemente vinculada a la existencia de la clase contenedora.\n</code></pre>","children":[],"payload":{"lines":"251,252"}}],"payload":{"lines":"250,251"}},{"content":"4. <strong>Herencia (Generalización):</strong>","children":[{"content":"Representa una relación de \"es-un\". Una clase (subclase) hereda atributos y comportamientos de otra clase (superclase).","children":[],"payload":{"lines":"257,258"}},{"content":"Se representa con una línea sólida <strong>con una flecha cerrada y hueca</strong> que va desde la subclase hacia la superclase.","children":[],"payload":{"lines":"258,259"}},{"content":"<img src=\"image-3.png\" alt=\"Alt text\">","children":[],"payload":{"lines":"259,261"}}],"payload":{"lines":"256,257"}},{"content":"5. <strong>Realización (Implementación):</strong>","children":[{"content":"Indica que una clase implementa una interfaz o cumple con un contrato definido por una interfaz.","children":[],"payload":{"lines":"262,263"}},{"content":"Se representa con una línea punteada que va desde la clase implementadora hacia la interfaz.","children":[],"payload":{"lines":"263,265"}}],"payload":{"lines":"261,262"}},{"content":"6. <strong>Dependencia:</strong>","children":[{"content":"Indica que una clase depende de otra en algún grado. Un cambio en una clase puede afectar a la otra.","children":[],"payload":{"lines":"266,267"}},{"content":"Se representa con una línea punteada que va desde la clase dependiente hacia la clase de la que depende.","children":[],"payload":{"lines":"267,269"}}],"payload":{"lines":"265,266"}}],"payload":{"lines":"232,233"}},{"content":"Consecuencias sobre el código Java","children":[{"content":"1. <strong>Asociación:</strong>","children":[{"content":"<pre data-lines=\"277,288\"><code class=\"language-java\"><span class=\"hljs-comment\">// Ejemplo de asociación unidireccional</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> {\n    <span class=\"hljs-keyword\">private</span> B b;\n    <span class=\"hljs-comment\">// ...</span>\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> {\n    <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>","children":[],"payload":{"lines":"277,288"}}],"payload":{"lines":"274,275"}},{"content":"2. <strong>Agregación:</strong>","children":[{"content":"<pre data-lines=\"292,299\"><code class=\"language-java\"><span class=\"hljs-comment\">// Ejemplo de agregación</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> {\n    <span class=\"hljs-keyword\">private</span> List&lt;B&gt; listaDeB;\n    <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>","children":[],"payload":{"lines":"292,299"}}],"payload":{"lines":"289,290"}},{"content":"3. <strong>Composición:</strong>","children":[{"content":"<pre data-lines=\"303,313\"><code class=\"language-java\"><span class=\"hljs-comment\">// Ejemplo de composición</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> {\n    <span class=\"hljs-keyword\">private</span> List&lt;B&gt; listaDeB;\n    <span class=\"hljs-comment\">// ...</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">A</span><span class=\"hljs-params\">()</span> {\n        listaDeB = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();\n    }\n}\n</code></pre>","children":[],"payload":{"lines":"303,313"}}],"payload":{"lines":"300,301"}},{"content":"4. <strong>Herencia:</strong>","children":[{"content":"<pre data-lines=\"317,327\"><code class=\"language-java\"><span class=\"hljs-comment\">// Ejemplo de herencia</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> {\n    <span class=\"hljs-comment\">// ...</span>\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">A</span> {\n    <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>","children":[],"payload":{"lines":"317,327"}}],"payload":{"lines":"314,315"}},{"content":"5. <strong>Realización (Implementación):</strong>","children":[{"content":"<pre data-lines=\"331,343\"><code class=\"language-java\"><span class=\"hljs-comment\">// Ejemplo de realización (implementación)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Interface</span> {\n    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">metodo</span><span class=\"hljs-params\">()</span>;\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Interface</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">metodo</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-comment\">// Implementación del método</span>\n    }\n}\n</code></pre>","children":[],"payload":{"lines":"331,343"}}],"payload":{"lines":"328,329"}}],"payload":{"lines":"271,272"}},{"content":"Otros modificadores","children":[{"content":"1. <strong>Static:</strong>","children":[{"content":"<strong>Significado:</strong> Indica que un miembro (método o atributo) pertenece a la clase en lugar de a las instancias individuales de la clase. Un miembro estático se comparte entre todas las instancias de la clase y se accede a través del nombre de la clase, no de una instancia.","children":[],"payload":{"lines":"350,351"}},{"content":"<strong>Representación en UML:</strong> Se indica colocando la palabra \"static\" antes del nombre del miembro.","children":[],"payload":{"lines":"351,352"}},{"content":"<strong>Ejemplo en Java:</strong>\n<pre data-lines=\"353,361\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Ejemplo</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">contador</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">incrementarContador</span><span class=\"hljs-params\">()</span> {\n        contador++;\n    }\n}\n</code></pre>","children":[{"content":"<pre data-lines=\"353,361\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Ejemplo</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">contador</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">incrementarContador</span><span class=\"hljs-params\">()</span> {\n        contador++;\n    }\n}\n</code></pre>","children":[],"payload":{"lines":"353,361"}}],"payload":{"lines":"352,362"}}],"payload":{"lines":"349,350"}},{"content":"2. <strong>Final:</strong>","children":[{"content":"<strong>Significado:</strong> Indica que un miembro no puede ser modificado después de su inicialización. En el caso de clases, impide que la clase sea subclase (heredada). En el caso de métodos, impide que el método sea sobrescrito en subclases.","children":[],"payload":{"lines":"363,364"}},{"content":"<strong>Representación en UML:</strong> Se indica agregando \"{final}\" después del nombre del miembro.","children":[],"payload":{"lines":"364,365"}},{"content":"<strong>Ejemplo en Java:</strong>\n<pre data-lines=\"366,374\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Ejemplo</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">valorConstante</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">10</span>;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">metodoFinal</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-comment\">// código del método</span>\n    }\n}\n</code></pre>","children":[{"content":"<pre data-lines=\"366,374\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Ejemplo</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">valorConstante</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">10</span>;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">metodoFinal</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-comment\">// código del método</span>\n    }\n}\n</code></pre>","children":[],"payload":{"lines":"366,374"}}],"payload":{"lines":"365,375"}}],"payload":{"lines":"362,363"}},{"content":"3. <strong>Abstract:</strong>","children":[{"content":"<strong>Significado:</strong> Indica que una clase o método no puede ser instanciado directamente o que un método no tiene implementación en la clase actual y debe ser proporcionado por subclases (en el caso de métodos abstractos). Las clases abstractas pueden tener métodos concretos y abstractos.","children":[],"payload":{"lines":"376,377"}},{"content":"<strong>Representación en UML:</strong> Se indica agregando \"{abstract}\" antes del nombre de la clase o el método.","children":[],"payload":{"lines":"377,378"}},{"content":"<strong>Ejemplo en Java:</strong>\n<pre data-lines=\"379,384\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Figura</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">calcularArea</span><span class=\"hljs-params\">()</span>;\n}\n</code></pre>","children":[{"content":"<pre data-lines=\"379,384\"><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Figura</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">calcularArea</span><span class=\"hljs-params\">()</span>;\n}\n</code></pre>","children":[],"payload":{"lines":"379,384"}}],"payload":{"lines":"378,385"}}],"payload":{"lines":"375,376"}},{"content":"1. <strong>Static:</strong>","children":[{"content":"Los miembros estáticos pertenecen a la clase y no a las instancias individuales. Pueden ser accedidos a través del nombre de la clase, y cualquier modificación se reflejará en todas las instancias.","children":[],"payload":{"lines":"388,389"}},{"content":"No es necesario crear una instancia de la clase para acceder a los miembros estáticos.","children":[],"payload":{"lines":"389,390"}},{"content":"Se comparten entre todas las instancias y existen durante toda la vida del programa.","children":[],"payload":{"lines":"390,392"}}],"payload":{"lines":"387,388"}},{"content":"2. <strong>Final:</strong>","children":[{"content":"Un miembro final no puede ser modificado después de su inicialización. Si es una variable, su valor no puede cambiar. Si es un método, no puede ser sobrescrito en subclases.","children":[],"payload":{"lines":"393,394"}},{"content":"Las clases finales no pueden ser heredadas. Esto asegura que la estructura de la clase final no se modifique.","children":[],"payload":{"lines":"394,396"}}],"payload":{"lines":"392,393"}},{"content":"3. <strong>Abstract:</strong>","children":[{"content":"Las clases abstractas no pueden ser instanciadas directamente. Se deben heredar y proporcionar implementaciones para sus métodos abstractos en las subclases.","children":[],"payload":{"lines":"397,398"}},{"content":"Los métodos abstractos no tienen implementación en la clase actual y deben ser proporcionados por las subclases. Estas subclases deben ser abstractas o proporcionar una implementación concreta para el método abstracto.","children":[],"payload":{"lines":"398,400"}}],"payload":{"lines":"396,397"}}],"payload":{"lines":"346,347"}}],"payload":{"lines":"198,199"}}],"payload":{"lines":"1,2"}},{"colorFreezeLevel":2})</script>
</body>
</html>
